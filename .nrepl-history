                                  (index-of 
                                    (vec (map :route-name (:children routes-map))) 
                                            (str "/" fxs))
                                  ))
      :else (recur xs (get (:children routes-map) idx))
      ))
  )
(loop [route (clojure.string/split "/" #"/")
       routes-map (-> @mon :route-widget :routes-map)]
  (let [x (first route)
        xs (rest route)
        fxs (first xs) 
        idx (index-of (vec (map :route-name (:children routes-map))) x)]
    (println "routes-map: " routes-map)
    (cond 
      (empty? xs) (:widgets routes-map)
      (= "" x) (recur (rest xs) (get 
                                  (:children routes-map)
                                  (index-of 
                                    (vec (map :route-name (:children routes-map))) 
                                            (str "/" fxs))
                                  ))
      :else (recur xs (get (:children routes-map) idx))
      ))
  )
(loop [route (clojure.string/split "/" #"/")
       routes-map (-> @mon :route-widget :routes-map)]
  (let [x (first route)
        xs (rest route)
        fxs (first xs) 
        idx (index-of (vec (map :route-name (:children routes-map))) x)]
    (println "routes-map: " routes-map)
    (cond 
      (empty? xs) (:widgets routes-map)
      (= "" x) (recur (rest xs) (get 
                                  (:children routes-map)
                                  (index-of 
                                    (vec (map :route-name (:children routes-map))) 
                                            (str "/" fxs))
                                  ))
      :else (recur xs (get (:children routes-map) idx))
      ))
  )
(loop [route (clojure.string/split "/" #"/")
       routes-map (-> @mon :route-widget :routes-map)]
  (let [x (first route)
        xs (rest route)
        fxs (first xs) 
        idx (index-of (vec (map :route-name (:children routes-map))) x)]
    (println "routes-map: " routes-map)
    (cond 
      (empty? xs) (:widgets routes-map)
      (= "" x) (recur (rest xs) (get 
                                  (:children routes-map)
                                  (index-of 
                                    (vec (map :route-name (:children routes-map))) 
                                            (str "/" fxs))
                                  ))
      :else (recur xs (get (:children routes-map) idx))
      ))
  )
(loop [route (clojure.string/split "/routea" #"/")
       routes-map (-> @mon :route-widget :routes-map)]
  (let [x (first route)
        xs (rest route)
        fxs (first xs) 
        idx (index-of (vec (map :route-name (:children routes-map))) x)]
    (println "routes-map: " routes-map)
    (cond 
      (empty? xs) (:widgets routes-map)
      (= "" x) (recur (rest xs) (get 
                                  (:children routes-map)
                                  (index-of 
                                    (vec (map :route-name (:children routes-map))) 
                                            (str "/" fxs))
                                  ))
      :else (recur xs (get (:children routes-map) idx))
      ))
  )
(loop [route (clojure.string/split "/routea/routeaa" #"/")
       routes-map (-> @mon :route-widget :routes-map)]
  (let [x (first route)
        xs (rest route)
        fxs (first xs) 
        idx (index-of (vec (map :route-name (:children routes-map))) x)]
    (println "routes-map: " routes-map)
    (cond 
      (empty? xs) (:widgets routes-map)
      (= "" x) (recur (rest xs) (get 
                                  (:children routes-map)
                                  (index-of 
                                    (vec (map :route-name (:children routes-map))) 
                                            (str "/" fxs))
                                  ))
      :else (recur xs (get (:children routes-map) idx))
      ))
  )
monolith
  (def mon monolith)
mon
(loop [route (clojure.string/split "/routea/routeaa" #"/")
       routes-map (-> @mon :route-widget :routes-map)]
  (let [x (first route)
        xs (rest route)
        fxs (first xs) 
        idx (index-of (vec (map :route-name (:children routes-map))) x)]
    (println "routes-map: " routes-map)
    (cond 
      (empty? xs) (:widgets routes-map)
      (= "" x) (recur (rest xs) (get 
                                  (:children routes-map)
                                  (index-of 
                                    (vec (map :route-name (:children routes-map))) 
                                            (str "/" fxs))
                                  ))
      :else (recur xs (get (:children routes-map) idx))
      ))
  )
(loop [route (clojure.string/split "/routea/routeaa" #"/")
       routes-map (-> @mon :route-widget :routes-map)]
  (let [x (first route)
        xs (rest route)
        fxs (first xs) 
        idx (index-of (vec (map :route-name (:children routes-map))) x)]
    (println "routes-map: " routes-map)
    (cond 
      (empty? xs) (:widgets routes-map)
      (= "" x) (recur xs (get 
                           (:children routes-map)
                           (index-of 
                             (vec (map :route-name (:children routes-map))) 
                             (str "/" fxs))
                           ))
     
      ))
  )
(loop [route (clojure.string/split "/routea/routeaa" #"/")
       routes-map (-> @mon :route-widget :routes-map)]
  (let [x (first route)
        xs (rest route)
        fxs (first xs) 
        idx (index-of (vec (map :route-name (:children routes-map))) x)]
    (println "routes-map: " routes-map)
    (cond 
      (empty? xs) (:widgets routes-map)
      (= "" x) (recur xs (get 
                           (:children routes-map)
                           (index-of 
                             (vec (map :route-name (:children routes-map))) 
                             (str "/" fxs))
                           ))
     
      ))
  )
(loop [route (clojure.string/split "/routea/routeaa" #"/")
       routes-map (-> @mon :route-widget :routes-map)]
  (let [x (first route)
        xs (rest route)
        fxs (first xs) 
        idx (index-of (vec (map :route-name (:children routes-map))) x)]
    (println "routes-map: " routes-map)
    (cond 
      (empty? xs) (:widgets routes-map)
      (= "" x) (recur xs (get 
                           (:children routes-map)
                           (index-of 
                             (vec (map :route-name (:children routes-map))) 
                             (str "/" fxs))
                           ))
      :else (recur xs (get (:children routes-map) idx))
      ))
  )
(loop [route (clojure.string/split "/routea/routeaa" #"/")
       routes-map (-> @mon :route-widget :routes-map)]
  (let [x (first route)
        xs (rest route)
        fxs (first xs) 
        idx (index-of (vec (map :route-name (:children routes-map))) x)]
    (println "routes-map: " routes-map)
    (cond 
      (empty? xs) (:widgets routes-map)
      (= "" x) (recur xs (get 
                           (:children routes-map)
                           (index-of 
                             (vec (map :route-name (:children routes-map))) 
                             (str "/" fxs))
                           ))
      :else (recur xs (get (:children routes-map) idx))
      ))
  )
(loop [route (clojure.string/split "/routea/routeaa" #"/")
       routes-map (-> @mon :route-widget :routes-map)]
  (let [x (first route)
        xs (rest route)
        fxs (first xs) 
        idx (index-of (vec (map :route-name (:children routes-map))) x)]
    (println "routes-map: " routes-map)
    (println "xs: " xs)
    (cond 
      (empty? xs) (:widgets routes-map)
      (= "" x) (recur xs (get 
                           (:children routes-map)
                           (index-of 
                             (vec (map :route-name (:children routes-map))) 
                             (str "/" fxs))
                           ))
      :else (recur xs (get (:children routes-map) idx))
      ))
  )
(loop [route (clojure.string/split "/routea/routeaa" #"/")
       routes-map (-> @mon :route-widget :routes-map)]
  (let [x (first route)
        xs (rest route)
        fxs (first xs) 
        idx (index-of (vec (map :route-name (:children routes-map))) x)]
    (println "xs: " xs)
    (println "routes-map: " routes-map)
    (cond 
      (empty? xs) (:widgets routes-map)
      (= "" x) (recur xs (get 
                           (:children routes-map)
                           (index-of 
                             (vec (map :route-name (:children routes-map))) 
                             (str "/" fxs))
                           ))
      :else (recur xs (get (:children routes-map) idx))
      ))
  )
(loop [route (clojure.string/split "/routea/routeaa" #"/")
       routes-map (-> @mon :route-widget :routes-map)]
  (let [x (first route)
        xs (rest route)
        fxs (first xs) 
        idx (index-of (vec (map :route-name (:children routes-map))) x)]
    (println "x: " x)
    (println "xs: " xs)
    (println "routes-map: " routes-map)
    (cond 
      (empty? xs) (:widgets routes-map)
      (= "" x) (recur xs (get 
                           (:children routes-map)
                           (index-of 
                             (vec (map :route-name (:children routes-map))) 
                             (str "/" fxs))
                           ))
      :else (recur xs (get (:children routes-map) idx))
      ))
  )
(loop [route (clojure.string/split "/routea/routeaa" #"/")
       routes-map (-> @mon :route-widget :routes-map)]
  (let [x (first route)
        xs (rest route)
        fxs (first xs) 
        idx (index-of (vec (map :route-name (:children routes-map))) x)]
    (println "x: " x)
    (println "xs: " xs)
    (println "routes-map: " routes-map)
    (cond 
      (empty? xs) (:widgets routes-map)
      (= "" x) (recur xs (get 
                           (:children routes-map)
                           (index-of 
                             (vec (map :route-name (:children routes-map))) 
                             (str "/" fxs))
                           ))
      :else (recur xs (get 
                           (:children routes-map)
                           (index-of 
                             (vec (map :route-name (:children routes-map))) 
                             (str "/" fxs))))
      ))
  )
(loop [route (clojure.string/split "/routea" #"/")
       routes-map (-> @mon :route-widget :routes-map)]
  (let [x (first route)
        xs (rest route)
        fxs (first xs) 
        idx (index-of (vec (map :route-name (:children routes-map))) x)]
    (println "x: " x)
    (println "xs: " xs)
    (println "routes-map: " routes-map)
    (cond 
      (empty? xs) (:widgets routes-map)
      (= "" x) (recur xs (get 
                           (:children routes-map)
                           (index-of 
                             (vec (map :route-name (:children routes-map))) 
                             (str "/" fxs))
                           ))
      :else (recur xs (get 
                           (:children routes-map)
                           (index-of 
                             (vec (map :route-name (:children routes-map))) 
                             (str "/" fxs))))
      ))
  )
(loop [route (clojure.string/split "/" #"/")
       routes-map (-> @mon :route-widget :routes-map)]
  (let [x (first route)
        xs (rest route)
        fxs (first xs) 
        idx (index-of (vec (map :route-name (:children routes-map))) x)]
    (println "x: " x)
    (println "xs: " xs)
    (println "routes-map: " routes-map)
    (cond 
      (empty? xs) (:widgets routes-map)
      (= "" x) (recur xs (get 
                           (:children routes-map)
                           (index-of 
                             (vec (map :route-name (:children routes-map))) 
                             (str "/" fxs))
                           ))
      :else (recur xs (get 
                           (:children routes-map)
                           (index-of 
                             (vec (map :route-name (:children routes-map))) 
                             (str "/" fxs))))
      ))
  )
(loop [route (clojure.string/split "/routea/routeaa" #"/")
       routes-map (-> @mon :route-widget :routes-map)]
  (let [x (first route)
        xs (rest route)
        fxs (first xs) 
        idx (index-of (vec (map :route-name (:children routes-map))) x)]
    (println "x: " x)
    (println "xs: " xs)
    (println "routes-map: " routes-map)
    (cond 
      (empty? xs) (:widgets routes-map)
      (= "" x) (recur xs (get 
                           (:children routes-map)
                           (index-of 
                             (vec (map :route-name (:children routes-map))) 
                             (str "/" fxs))
                           ))
      :else (recur xs (get 
                           (:children routes-map)
                           (index-of 
                             (vec (map :route-name (:children routes-map))) 
                             (str "/" fxs))))
      ))
  )
(loop [route (clojure.string/split "/routea/routeaa" #"/")
       routes-map (-> @mon :route-widget :routes-map)]
  (let [x (first route)
        xs (rest route)
        fxs (first xs) 
        idx (index-of 
                             (vec (map :route-name (:children routes-map))) 
                             (str "/" fxs))]
    (println "x: " x)
    (println "xs: " xs)
    (println "routes-map: " routes-map)
    (cond 
      (empty? xs) (:widgets routes-map)
      (= "" x) (recur xs (get 
                           (:children routes-map)
                          idx 
                           ))
      :else (recur xs (get 
                        (:children routes-map)
                        idx)))))
(loop [route (clojure.string/split "/routea" #"/")
       routes-map (-> @mon :route-widget :routes-map)]
  (let [x (first route)
        xs (rest route)
        fxs (first xs) 
        idx (index-of 
                             (vec (map :route-name (:children routes-map))) 
                             (str "/" fxs))]
    (println "x: " x)
    (println "xs: " xs)
    (println "routes-map: " routes-map)
    (cond 
      (empty? xs) (:widgets routes-map)
      (= "" x) (recur xs (get 
                           (:children routes-map)
                          idx 
                           ))
      :else (recur xs (get 
                        (:children routes-map)
                        idx)))))
(loop [route (clojure.string/split "/" #"/")
       routes-map (-> @mon :route-widget :routes-map)]
  (let [x (first route)
        xs (rest route)
        fxs (first xs) 
        idx (index-of 
                             (vec (map :route-name (:children routes-map))) 
                             (str "/" fxs))]
    (println "x: " x)
    (println "xs: " xs)
    (println "routes-map: " routes-map)
    (cond 
      (empty? xs) (:widgets routes-map)
      (= "" x) (recur xs (get 
                           (:children routes-map)
                          idx 
                           ))
      :else (recur xs (get 
                        (:children routes-map)
                        idx)))))
(loop [route (clojure.string/split "/routea/routeaa" #"/")
       routes-map (-> @mon :route-widget :routes-map)]
  (let [x (first route)
        xs (rest route)
        fxs (first xs) 
        idx (index-of 
                             (vec (map :route-name (:children routes-map))) 
                             (str "/" fxs))]
    (println "x: " x)
    (println "xs: " xs)
    (println "routes-map: " routes-map)
    (cond 
      (empty? xs) (:widgets routes-map)
      (= "" x) (recur xs (get 
                           (:children routes-map)
                          idx 
                           ))
      :else (recur xs (get 
                        (:children routes-map)
                        idx)))))
(loop [route (clojure.string/split "/routea/routeaa" #"/")
       routes-map (-> @mon :route-widget :routes-map)]
  (let [x (first route)
        xs (rest route)
        fxs (first xs) 
        idx (index-of (vec (map :route-name (:children routes-map))) (str "/" fxs))]
    (println "x: " x)
    (println "xs: " xs)
    (println "routes-map: " routes-map)
    (cond 
      (empty? xs) (:widgets routes-map)
      :else (recur xs (get (:children routes-map) idx)))))
(loop [route (clojure.string/split "/routea" #"/")
       routes-map (-> @mon :route-widget :routes-map)]
  (let [x (first route)
        xs (rest route)
        fxs (first xs) 
        idx (index-of (vec (map :route-name (:children routes-map))) (str "/" fxs))]
    (println "x: " x)
    (println "xs: " xs)
    (println "routes-map: " routes-map)
    (cond 
      (empty? xs) (:widgets routes-map)
      :else (recur xs (get (:children routes-map) idx)))))
(loop [route (clojure.string/split "/" #"/")
       routes-map (-> @mon :route-widget :routes-map)]
  (let [x (first route)
        xs (rest route)
        fxs (first xs) 
        idx (index-of (vec (map :route-name (:children routes-map))) (str "/" fxs))]
    (println "x: " x)
    (println "xs: " xs)
    (println "routes-map: " routes-map)
    (cond 
      (empty? xs) (:widgets routes-map)
      :else (recur xs (get (:children routes-map) idx)))))
(loop [route (clojure.string/split "/routea/routeaa" #"/")
       routes-map (-> @mon :route-widget :routes-map)]
  (let [x (first route)
        xs (rest route)
        fxs (first xs) 
        idx (index-of (vec (map :route-name (:children routes-map))) (str "/" fxs))]
    (println "x: " x)
    (println "xs: " xs)
    (println "routes-map: " routes-map)
    (cond 
      (empty? xs) (:widgets routes-map)
      :else (recur xs (get (:children routes-map) idx)))))
(loop [route (clojure.string/split "/routea" #"/")
       routes-map (-> @mon :route-widget :routes-map)]
  (let [x (first route)
        xs (rest route)
        fxs (first xs) 
        idx (index-of (vec (map :route-name (:children routes-map))) (str "/" fxs))]
    (println "x: " x)
    (println "xs: " xs)
    (println "routes-map: " routes-map)
    (cond 
      (empty? xs) (:widgets routes-map)
      :else (recur xs (get (:children routes-map) idx)))))
(defn current-widgets [route routes-map]
  (let [xs (rest route)
        fxs (first xs) 
        idx (index-of (vec (map :route-name (:children routes-map))) (str "/" fxs))]
    (cond 
      (empty? xs) (:widgets routes-map)
      :else (current-widgets xs (get (:children routes-map) idx)))))
(current-widgets 
  (clojure.string/split "/routea/routeaa" #"/")
(-> @mon :route-widget :routes-map)
  )
(current-widgets 
  (clojure.string/split "/routea" #"/")
  (-> @mon :route-widget :routes-map)
  )
mon
