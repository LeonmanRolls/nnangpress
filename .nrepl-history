  )
(loop [route (clojure.string/split "/" #"/")
       routes-map (-> @mon :route-widget :routes-map)]
  (let [x (first route)
        xs (rest route)
        fxs (first xs) 
        idx (index-of (vec (map :route-name (:children routes-map))) x)]
    (println "routes-map: " routes-map)
    (cond 
      (empty? xs) (:widgets routes-map)
      (= "" x) (recur (rest xs) (get 
                                  (:children routes-map)
                                  (index-of 
                                    (vec (map :route-name (:children routes-map))) 
                                            (str "/" fxs))
                                  ))
      :else (recur xs (get (:children routes-map) idx))
      ))
  )
(loop [route (clojure.string/split "/" #"/")
       routes-map (-> @mon :route-widget :routes-map)]
  (let [x (first route)
        xs (rest route)
        fxs (first xs) 
        idx (index-of (vec (map :route-name (:children routes-map))) x)]
    (println "routes-map: " routes-map)
    (cond 
      (empty? xs) (:widgets routes-map)
      (= "" x) (recur (rest xs) (get 
                                  (:children routes-map)
                                  (index-of 
                                    (vec (map :route-name (:children routes-map))) 
                                            (str "/" fxs))
                                  ))
      :else (recur xs (get (:children routes-map) idx))
      ))
  )
(loop [route (clojure.string/split "/routea" #"/")
       routes-map (-> @mon :route-widget :routes-map)]
  (let [x (first route)
        xs (rest route)
        fxs (first xs) 
        idx (index-of (vec (map :route-name (:children routes-map))) x)]
    (println "routes-map: " routes-map)
    (cond 
      (empty? xs) (:widgets routes-map)
      (= "" x) (recur (rest xs) (get 
                                  (:children routes-map)
                                  (index-of 
                                    (vec (map :route-name (:children routes-map))) 
                                            (str "/" fxs))
                                  ))
      :else (recur xs (get (:children routes-map) idx))
      ))
  )
(loop [route (clojure.string/split "/routea/routeaa" #"/")
       routes-map (-> @mon :route-widget :routes-map)]
  (let [x (first route)
        xs (rest route)
        fxs (first xs) 
        idx (index-of (vec (map :route-name (:children routes-map))) x)]
    (println "routes-map: " routes-map)
    (cond 
      (empty? xs) (:widgets routes-map)
      (= "" x) (recur (rest xs) (get 
                                  (:children routes-map)
                                  (index-of 
                                    (vec (map :route-name (:children routes-map))) 
                                            (str "/" fxs))
                                  ))
      :else (recur xs (get (:children routes-map) idx))
      ))
  )
monolith
  (def mon monolith)
mon
(loop [route (clojure.string/split "/routea/routeaa" #"/")
       routes-map (-> @mon :route-widget :routes-map)]
  (let [x (first route)
        xs (rest route)
        fxs (first xs) 
        idx (index-of (vec (map :route-name (:children routes-map))) x)]
    (println "routes-map: " routes-map)
    (cond 
      (empty? xs) (:widgets routes-map)
      (= "" x) (recur (rest xs) (get 
                                  (:children routes-map)
                                  (index-of 
                                    (vec (map :route-name (:children routes-map))) 
                                            (str "/" fxs))
                                  ))
      :else (recur xs (get (:children routes-map) idx))
      ))
  )
(loop [route (clojure.string/split "/routea/routeaa" #"/")
       routes-map (-> @mon :route-widget :routes-map)]
  (let [x (first route)
        xs (rest route)
        fxs (first xs) 
        idx (index-of (vec (map :route-name (:children routes-map))) x)]
    (println "routes-map: " routes-map)
    (cond 
      (empty? xs) (:widgets routes-map)
      (= "" x) (recur xs (get 
                           (:children routes-map)
                           (index-of 
                             (vec (map :route-name (:children routes-map))) 
                             (str "/" fxs))
                           ))
     
      ))
  )
(loop [route (clojure.string/split "/routea/routeaa" #"/")
       routes-map (-> @mon :route-widget :routes-map)]
  (let [x (first route)
        xs (rest route)
        fxs (first xs) 
        idx (index-of (vec (map :route-name (:children routes-map))) x)]
    (println "routes-map: " routes-map)
    (cond 
      (empty? xs) (:widgets routes-map)
      (= "" x) (recur xs (get 
                           (:children routes-map)
                           (index-of 
                             (vec (map :route-name (:children routes-map))) 
                             (str "/" fxs))
                           ))
     
      ))
  )
(loop [route (clojure.string/split "/routea/routeaa" #"/")
       routes-map (-> @mon :route-widget :routes-map)]
  (let [x (first route)
        xs (rest route)
        fxs (first xs) 
        idx (index-of (vec (map :route-name (:children routes-map))) x)]
    (println "routes-map: " routes-map)
    (cond 
      (empty? xs) (:widgets routes-map)
      (= "" x) (recur xs (get 
                           (:children routes-map)
                           (index-of 
                             (vec (map :route-name (:children routes-map))) 
                             (str "/" fxs))
                           ))
      :else (recur xs (get (:children routes-map) idx))
      ))
  )
(loop [route (clojure.string/split "/routea/routeaa" #"/")
       routes-map (-> @mon :route-widget :routes-map)]
  (let [x (first route)
        xs (rest route)
        fxs (first xs) 
        idx (index-of (vec (map :route-name (:children routes-map))) x)]
    (println "routes-map: " routes-map)
    (cond 
      (empty? xs) (:widgets routes-map)
      (= "" x) (recur xs (get 
                           (:children routes-map)
                           (index-of 
                             (vec (map :route-name (:children routes-map))) 
                             (str "/" fxs))
                           ))
      :else (recur xs (get (:children routes-map) idx))
      ))
  )
(loop [route (clojure.string/split "/routea/routeaa" #"/")
       routes-map (-> @mon :route-widget :routes-map)]
  (let [x (first route)
        xs (rest route)
        fxs (first xs) 
        idx (index-of (vec (map :route-name (:children routes-map))) x)]
    (println "routes-map: " routes-map)
    (println "xs: " xs)
    (cond 
      (empty? xs) (:widgets routes-map)
      (= "" x) (recur xs (get 
                           (:children routes-map)
                           (index-of 
                             (vec (map :route-name (:children routes-map))) 
                             (str "/" fxs))
                           ))
      :else (recur xs (get (:children routes-map) idx))
      ))
  )
(loop [route (clojure.string/split "/routea/routeaa" #"/")
       routes-map (-> @mon :route-widget :routes-map)]
  (let [x (first route)
        xs (rest route)
        fxs (first xs) 
        idx (index-of (vec (map :route-name (:children routes-map))) x)]
    (println "xs: " xs)
    (println "routes-map: " routes-map)
    (cond 
      (empty? xs) (:widgets routes-map)
      (= "" x) (recur xs (get 
                           (:children routes-map)
                           (index-of 
                             (vec (map :route-name (:children routes-map))) 
                             (str "/" fxs))
                           ))
      :else (recur xs (get (:children routes-map) idx))
      ))
  )
(loop [route (clojure.string/split "/routea/routeaa" #"/")
       routes-map (-> @mon :route-widget :routes-map)]
  (let [x (first route)
        xs (rest route)
        fxs (first xs) 
        idx (index-of (vec (map :route-name (:children routes-map))) x)]
    (println "x: " x)
    (println "xs: " xs)
    (println "routes-map: " routes-map)
    (cond 
      (empty? xs) (:widgets routes-map)
      (= "" x) (recur xs (get 
                           (:children routes-map)
                           (index-of 
                             (vec (map :route-name (:children routes-map))) 
                             (str "/" fxs))
                           ))
      :else (recur xs (get (:children routes-map) idx))
      ))
  )
(loop [route (clojure.string/split "/routea/routeaa" #"/")
       routes-map (-> @mon :route-widget :routes-map)]
  (let [x (first route)
        xs (rest route)
        fxs (first xs) 
        idx (index-of (vec (map :route-name (:children routes-map))) x)]
    (println "x: " x)
    (println "xs: " xs)
    (println "routes-map: " routes-map)
    (cond 
      (empty? xs) (:widgets routes-map)
      (= "" x) (recur xs (get 
                           (:children routes-map)
                           (index-of 
                             (vec (map :route-name (:children routes-map))) 
                             (str "/" fxs))
                           ))
      :else (recur xs (get 
                           (:children routes-map)
                           (index-of 
                             (vec (map :route-name (:children routes-map))) 
                             (str "/" fxs))))
      ))
  )
(loop [route (clojure.string/split "/routea" #"/")
       routes-map (-> @mon :route-widget :routes-map)]
  (let [x (first route)
        xs (rest route)
        fxs (first xs) 
        idx (index-of (vec (map :route-name (:children routes-map))) x)]
    (println "x: " x)
    (println "xs: " xs)
    (println "routes-map: " routes-map)
    (cond 
      (empty? xs) (:widgets routes-map)
      (= "" x) (recur xs (get 
                           (:children routes-map)
                           (index-of 
                             (vec (map :route-name (:children routes-map))) 
                             (str "/" fxs))
                           ))
      :else (recur xs (get 
                           (:children routes-map)
                           (index-of 
                             (vec (map :route-name (:children routes-map))) 
                             (str "/" fxs))))
      ))
  )
(loop [route (clojure.string/split "/" #"/")
       routes-map (-> @mon :route-widget :routes-map)]
  (let [x (first route)
        xs (rest route)
        fxs (first xs) 
        idx (index-of (vec (map :route-name (:children routes-map))) x)]
    (println "x: " x)
    (println "xs: " xs)
    (println "routes-map: " routes-map)
    (cond 
      (empty? xs) (:widgets routes-map)
      (= "" x) (recur xs (get 
                           (:children routes-map)
                           (index-of 
                             (vec (map :route-name (:children routes-map))) 
                             (str "/" fxs))
                           ))
      :else (recur xs (get 
                           (:children routes-map)
                           (index-of 
                             (vec (map :route-name (:children routes-map))) 
                             (str "/" fxs))))
      ))
  )
(loop [route (clojure.string/split "/routea/routeaa" #"/")
       routes-map (-> @mon :route-widget :routes-map)]
  (let [x (first route)
        xs (rest route)
        fxs (first xs) 
        idx (index-of (vec (map :route-name (:children routes-map))) x)]
    (println "x: " x)
    (println "xs: " xs)
    (println "routes-map: " routes-map)
    (cond 
      (empty? xs) (:widgets routes-map)
      (= "" x) (recur xs (get 
                           (:children routes-map)
                           (index-of 
                             (vec (map :route-name (:children routes-map))) 
                             (str "/" fxs))
                           ))
      :else (recur xs (get 
                           (:children routes-map)
                           (index-of 
                             (vec (map :route-name (:children routes-map))) 
                             (str "/" fxs))))
      ))
  )
(loop [route (clojure.string/split "/routea/routeaa" #"/")
       routes-map (-> @mon :route-widget :routes-map)]
  (let [x (first route)
        xs (rest route)
        fxs (first xs) 
        idx (index-of 
                             (vec (map :route-name (:children routes-map))) 
                             (str "/" fxs))]
    (println "x: " x)
    (println "xs: " xs)
    (println "routes-map: " routes-map)
    (cond 
      (empty? xs) (:widgets routes-map)
      (= "" x) (recur xs (get 
                           (:children routes-map)
                          idx 
                           ))
      :else (recur xs (get 
                        (:children routes-map)
                        idx)))))
(loop [route (clojure.string/split "/routea" #"/")
       routes-map (-> @mon :route-widget :routes-map)]
  (let [x (first route)
        xs (rest route)
        fxs (first xs) 
        idx (index-of 
                             (vec (map :route-name (:children routes-map))) 
                             (str "/" fxs))]
    (println "x: " x)
    (println "xs: " xs)
    (println "routes-map: " routes-map)
    (cond 
      (empty? xs) (:widgets routes-map)
      (= "" x) (recur xs (get 
                           (:children routes-map)
                          idx 
                           ))
      :else (recur xs (get 
                        (:children routes-map)
                        idx)))))
(loop [route (clojure.string/split "/" #"/")
       routes-map (-> @mon :route-widget :routes-map)]
  (let [x (first route)
        xs (rest route)
        fxs (first xs) 
        idx (index-of 
                             (vec (map :route-name (:children routes-map))) 
                             (str "/" fxs))]
    (println "x: " x)
    (println "xs: " xs)
    (println "routes-map: " routes-map)
    (cond 
      (empty? xs) (:widgets routes-map)
      (= "" x) (recur xs (get 
                           (:children routes-map)
                          idx 
                           ))
      :else (recur xs (get 
                        (:children routes-map)
                        idx)))))
(loop [route (clojure.string/split "/routea/routeaa" #"/")
       routes-map (-> @mon :route-widget :routes-map)]
  (let [x (first route)
        xs (rest route)
        fxs (first xs) 
        idx (index-of 
                             (vec (map :route-name (:children routes-map))) 
                             (str "/" fxs))]
    (println "x: " x)
    (println "xs: " xs)
    (println "routes-map: " routes-map)
    (cond 
      (empty? xs) (:widgets routes-map)
      (= "" x) (recur xs (get 
                           (:children routes-map)
                          idx 
                           ))
      :else (recur xs (get 
                        (:children routes-map)
                        idx)))))
(loop [route (clojure.string/split "/routea/routeaa" #"/")
       routes-map (-> @mon :route-widget :routes-map)]
  (let [x (first route)
        xs (rest route)
        fxs (first xs) 
        idx (index-of (vec (map :route-name (:children routes-map))) (str "/" fxs))]
    (println "x: " x)
    (println "xs: " xs)
    (println "routes-map: " routes-map)
    (cond 
      (empty? xs) (:widgets routes-map)
      :else (recur xs (get (:children routes-map) idx)))))
(loop [route (clojure.string/split "/routea" #"/")
       routes-map (-> @mon :route-widget :routes-map)]
  (let [x (first route)
        xs (rest route)
        fxs (first xs) 
        idx (index-of (vec (map :route-name (:children routes-map))) (str "/" fxs))]
    (println "x: " x)
    (println "xs: " xs)
    (println "routes-map: " routes-map)
    (cond 
      (empty? xs) (:widgets routes-map)
      :else (recur xs (get (:children routes-map) idx)))))
(loop [route (clojure.string/split "/" #"/")
       routes-map (-> @mon :route-widget :routes-map)]
  (let [x (first route)
        xs (rest route)
        fxs (first xs) 
        idx (index-of (vec (map :route-name (:children routes-map))) (str "/" fxs))]
    (println "x: " x)
    (println "xs: " xs)
    (println "routes-map: " routes-map)
    (cond 
      (empty? xs) (:widgets routes-map)
      :else (recur xs (get (:children routes-map) idx)))))
(loop [route (clojure.string/split "/routea/routeaa" #"/")
       routes-map (-> @mon :route-widget :routes-map)]
  (let [x (first route)
        xs (rest route)
        fxs (first xs) 
        idx (index-of (vec (map :route-name (:children routes-map))) (str "/" fxs))]
    (println "x: " x)
    (println "xs: " xs)
    (println "routes-map: " routes-map)
    (cond 
      (empty? xs) (:widgets routes-map)
      :else (recur xs (get (:children routes-map) idx)))))
(loop [route (clojure.string/split "/routea" #"/")
       routes-map (-> @mon :route-widget :routes-map)]
  (let [x (first route)
        xs (rest route)
        fxs (first xs) 
        idx (index-of (vec (map :route-name (:children routes-map))) (str "/" fxs))]
    (println "x: " x)
    (println "xs: " xs)
    (println "routes-map: " routes-map)
    (cond 
      (empty? xs) (:widgets routes-map)
      :else (recur xs (get (:children routes-map) idx)))))
(defn current-widgets [route routes-map]
  (let [xs (rest route)
        fxs (first xs) 
        idx (index-of (vec (map :route-name (:children routes-map))) (str "/" fxs))]
    (cond 
      (empty? xs) (:widgets routes-map)
      :else (current-widgets xs (get (:children routes-map) idx)))))
(current-widgets 
  (clojure.string/split "/routea/routeaa" #"/")
(-> @mon :route-widget :routes-map)
  )
(current-widgets 
  (clojure.string/split "/routea" #"/")
  (-> @mon :route-widget :routes-map)
  )
mon
(in-ns 'nnangpress.app)
(->
                                     (js/firebase.database)
                                     (.ref (str "users/" uid)))
(let [uid "SGXvf26OEpeVDQ79XIH2V71fVnT2"
                     user-data-ref (->
                                     (js/firebase.database)
                                     (.ref (str "users/" uid)))]
                 (prn "-- Atom Changed --")
                 (->
                   user-data-ref
                   (.set #js {:username "wellwell"
                              :email "leon.talbert@gmail.com"
                              :data  (pr-str @monolith)})))
(let [uid "SGXvf26OEpeVDQ79XIH2V71fVnT2"
        user-data-ref (->
                        (js/firebase.database)
                        (.ref (str "users/" uid)))]
    (prn "-- Atom Changed --")
    (->
      user-data-ref
      (.set #js {:username "wellwell"
                 :email "leon.talbert@gmail.com"
                 :data  (pr-str @mn/monolith)})))
